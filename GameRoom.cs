//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.18444
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Timers;
using Alchemy;
using Alchemy.Classes;

namespace PongServer
{
	public class GameRoom
	{
		UserContext firstPlayer;
		UserContext secondPlayer;

		private Timer tickTimer;
		private readonly Guid guid;
		private bool isRunning
		{
			get { return secondPlayer != null; }
		}
		
		private Game myGame;
	
		//Create a room, one player is already connected to the server
		public GameRoom(UserContext socket, Guid pGuid)
		{
			guid = pGuid;
			firstPlayer = socket;
			firstPlayer.Send("wait");
			MainClass.WriteLogMessage("Created room with ID " + guid);
		}

		//Let a second player join
		public void AddSecondPlayer(UserContext socket)
		{
			if(!isFull())
			{
				secondPlayer = socket;
				MainClass.WriteLogMessage("Room " + guid + " was filled.");
				StartNewGame();
			}
			else
			{
				throw new InvalidOperationException("A third player tried to join game " + guid + " !");
			}
		}

		//A player left, stop the game and remove the player
		public void RemovePlayerFromRoom(UserContext removePlayer)
		{
			if(removePlayer.Equals(firstPlayer))
			{
				firstPlayer = secondPlayer;
				secondPlayer = null;
			}
			else
			{
				secondPlayer = null;
			}

			tickTimer.Enabled = false;
			firstPlayer.Send("wait");
			MainClass.WriteLogMessage("Removed player from room " + guid + " .");
		}

		public List<UserContext> GetPlayers()
		{
			var playerList = new List<UserContext>();
			playerList.Add(firstPlayer);
			playerList.Add(secondPlayer);
			return playerList;
		}

		public void SetCursorPosition(UserContext sourceUser, int position)
		{
			if(!isFull())
				return;

			//If we got this position from the first player, send the position to the second player
			if(sourceUser == firstPlayer)
			{
				secondPlayer.Send("pos" + position);
				myGame.leftVerticalPos = position;
			}
			else
			{
				firstPlayer.Send("pos" + position);
				myGame.rightVerticalPos = position;
			}
		}
		
		private void StartNewGame()
		{
			myGame = new Game(GameScoreUpdate);

			tickTimer = new Timer(26);
			tickTimer.Elapsed += Update;
			tickTimer.Enabled = true;
		}

		//Called every 26 milliseconds
		private void Update(object sender, ElapsedEventArgs e)
		{
			myGame.Update();
			string leftBallString = "ball" + myGame.GetBallPosition(false).ToIntString() + "|" + myGame.GetBallSpeed(false).ToIntString();
			string rightBallString = "ball" + myGame.GetBallPosition(true).ToIntString() + "|" + myGame.GetBallSpeed(true).ToIntString(); //Send reversed values for right player
			SendToBoth(leftBallString, rightBallString);
		}

		private void GameScoreUpdate()
		{
			string leftMessage = "score" + myGame.GetLeftPoints() + "|" + myGame.GetRightPoints();
			string rightMessage = "score" + myGame.GetRightPoints() + "|" + myGame.GetLeftPoints();
			SendToBoth(leftMessage, rightMessage);
		}

		//Send the same message to both players
		private void SendToBoth(string message)
		{
			firstPlayer.Send(message);
			secondPlayer.Send(message);
		}

		//Send a different message to each player
		private void SendToBoth(string left, string right)
		{
			firstPlayer.Send(left);
			secondPlayer.Send(right);
		}

		//Stops the timer so no thread is running, should be called before removing the room
		public void StopTimer()
		{
			if(isRunning)
			{
				tickTimer.Stop();
				tickTimer.Close();
				tickTimer.Dispose();
				tickTimer = null;
				MainClass.WriteLogMessage("Stopped timer of room " + guid + " .", 1);
			}
		}
		
		public bool isFull()
		{
			return secondPlayer != null;
		}
	}
}